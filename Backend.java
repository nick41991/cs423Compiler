// This class converts an IR into ASM
// This will be primarily done by reading a line of IR and generating appropriate ASM for that line
import java.util.ArrayList;
import java.util.Stack;
import java.util.regex.*;


public class Backend {
	public ArrayList<String> output;
	public IntRep ir;

	private SymbolTable st; // Store main symbol table
	private String context; // Working table
	private ArrayList<String> functions; //Functions written
	private Stack<String> labelStack = new Stack<String>(); //Used for labels auto generated by compiler
	private MemoryManager memory;

	private boolean mainSet;

	private int jumpLabel;
	public int if_lbl_count = 0;
	public int ifelse_lbl_count = 0;
	public int while_lbl_count = 0;
	public int lse_flag = 0;

	public Backend(IntRep irep, SymbolTable sym){
		output = new ArrayList<String>();
		ir = irep;
		st = sym;
		jumpLabel = 0;
		functions = new ArrayList<String>();
		memory = new MemoryManager();
	}

	public void print(){
		for(String s: output){
			System.out.println(s);
		}
	}



	public void run(boolean asmBool){
		init();
		state_switch(0);
		if(asmBool) {
			print();
		}
	}

	/*Write the three necessary data sections to output*/
	public void init(){
		output.add(".section .data");
		output.add(".section .bss");
		output.add(".section .text");
	}

	/**
	Cases to handle:		id ir	write asm`
		Function declaration	+	+
		LabeledStatement	+	+
		SelectionStatement	+	-
		IterationStatement	+	-
		JumpStatement     	+	+
		returns			+	+
		ExpressionStatement	+	+ //Fallthrough case
	*/

	//Main control function, controls state of backend
	public int state_switch(int i){
		String s;
		String X;
		String Z;




		for(; i < ir.rep.size(); i++){
			s = ir.rep.get(i);
			System.out.println(i + " " + s);
			//Function Declaration
			if(Pattern.matches("[a-z][a-zA-Z_0-9]*[(][)][{]", s)){
				i = functionHeader(s, i);
			} else if (Pattern.matches("[A-Z][a-zA-Z_0-9]*[:]", s)){
				i = label(s,i);
			} else if (Pattern.matches("jmp [a-zA-Z][a-zA-Z_0-9]*", s)){
				i = jump(s, i);
			} else if (Pattern.matches("while [a-zA-Z][a-zA-Z_0-9]* [{]", s)){
				i = iterator(s, i);
			} else if (Pattern.matches("if [a-zA-Z][a-zA-Z_0-9]* [{]", s)){
				i = selectionIf(s, i);
					X = labelStack.pop();
					Z = labelStack.pop();
					labelStack.push(Z);
					labelStack.push(X);
					output.add(X + ":");

			} else if (Pattern.matches("[}] else [{]", s)){
				i = selectionElse(s, i);
				popLabel();
				return i;
			} else if (Pattern.matches("return [a-zA-Z][a-zA-Z_0-9]*", s)){
				i = returns(s, i);

			} else if (Pattern.matches("break", s)){
				i = breaks(s, i);

			} else if (Pattern.matches("[}]", s)){
				//End of ifs (w/out else), elses, whiles, and functions
				//Signals end of block
				return i;
			} else {
				//Assume expression
				expression(s, i);
			}

			//Regex Test Print
			//System.out.println(s + " " + Pattern.matches("[}] else if [a-zA-Z][a-zA-Z_0-9]* [{]", s));
		}
		return 0;
	}

	private int functionHeader(String s, int i){
		// write function head. Allocate space for variables on stack via symbol table.
		// call state_switch() to write function until "}" forces return

		//Get function name-- S format: "name(){"
		String name = "";
		for(int j = 0; j < s.length(); j++){
			if(s.charAt(j) == '('){
				name = s.substring(0, j);
				break;
			}
		}
		if(name.equals("")){ //Name resolution error should not happen without a significant bug
			System.out.println("Error: Function was identified but name could not be resolved: " + s);
			return i;
		}
		//Set entry point, using _start for main makes life easier

		output.add(".globl " + name);
		output.add(name + ":");

		/*Initialize stack for function*/
		output.add("pushq %rbp");
		output.add("movq %rsp, %rbp");

		//Use this table to allocate space on stack for local variables
		context = name;
		functions.add(name); // This makes it so that a function will not be known unless declared prior!

		//Default return
		return state_switch(i + 1);


	}

	private int label(String s, int i){
		//A user defined label in the code
		output.add(s);
		//Default return
		return i;
	}

	private int breaks(String s, int i){
		//A user defined break in the code
		output.add("jmp WHILE" + (while_lbl_count - 1));
		//Default return
		return i;
	}

	private int jump(String s, int i){
		//Unconditional YEET to a label
		//s = jmp LABEL
		output.add(s);
		//Default return
		return i;
	}

	private int iterator(String s, int i){
		//For s == "while cond {"

		/* code to be written
			test cond
			jump to x if false		//Push x onto label stack
			label y:			//y needs to be stored localy though until we return from state_switch()
				looped code (state_switch() to write)
				Condition recalculation is included in looped code via IR
 			test cond
			jump to y if true		//write jump using stored label y
			label x:			//pop x from label stack
				continuation of code outside this structure
		*/

		//Default return

		String label = new String("WHILE" + while_lbl_count);
		while_lbl_count++;


		return i;

	}

	private int selectionIf(String s, int i){ //if else
		//FOR: s == "if cond {"

		// For asm: test ph
		// jump to label x if test fails //label x is the next test for chained statements
		// code for if test doesn't fail, written by call to state_switch()
		// at the bottom of this code jump (unconditionally) to label y, the end of the if-else chain
		// place label x below the unconditional jump
		// x and y may point to the same instruction

		/*
			test cond
			jump if false to label x		push z to label stack then push x
				code for if true		written by call to state_switch()
				jump (unconditionally) to z
			label x:
			//if else will function just like a basic if.
			//x is popped before calling selectionIf() again
			test cond
			jump if false to label x		push z to label stack then push x
				code for if true
				jump (unconditionally) to z
			label x:

			label z:
				continuation of code outside this structure
		*/

		//Default return


		String x_lab = new String("IF" + if_lbl_count);
		String z_lab = new String("ELSE" + ifelse_lbl_count);
		if_lbl_count++;
		ifelse_lbl_count++;
		labelStack.push(z_lab);
		labelStack.push(x_lab);

		String [] tokens = s.split(" ");
		//System.out.println("in if condtional token[1] = "+ tokens[1] +"\n");

		ArrayList<String> condtional_regi = memory.accessReference(tokens[1], context);
		writeAccess(condtional_regi);
		output.add("cmp " + condtional_regi.get(condtional_regi.size() - 1) + ", 0");
		output.add("jne " + x_lab);

		i = state_switch(i+1);
		return i;










	}



	private int selectionElse(String s, int i){
		//FOR: s == "else {"

		//popLabel(); //Place label from prior if (x if no else-ifs)
		//Write code for else block via state_switch()
		//popLabel(); //Place final label (label z)

		//Default return

		//output.remove(output.size() -1);

		String X = labelStack.pop();
		String Z = labelStack.pop();
		labelStack.push(Z);
		labelStack.push(X);
		output.add("jmp " + Z);
		popLabel();
		lse_flag = 1;

		i = state_switch(i+1);

		return i;
	}

	/*Remove label from label stack and write label to output*/
	private void popLabel(){
		String label = labelStack.pop();
		output.add(label + ":");
	}

	private int returns(String s, int i){
		//FOR s == "return exp"

		/*
			Want to check register array and if need be stack for exp Location
			then load exp into %rax
			ret
		*/
		String [] tokens = s.split(" ");

		//Currently assuming return has been preloaded into %eax. Need code to enforce this.
		ArrayList<String> reference = memory.accessReference(tokens[1], "main");
		if(!reference.get(reference.size() - 1).equals("%eax")){
			/*Move return value into eax*/
			for(int j = 0; j < reference.size() - 1; j++){ //In case there was anything done to get return value into register.
				output.add(reference.get(j));
			}
			output.add("movl " + reference.get(reference.size() - 1) + ", %eax");
		}
		output.add("popq %rbp");
		output.add("ret\n");

		//Default return
		return i;
	}

	private int expression(String s, int i){
		//An expression may be of the  following forms:
		// L1 = const
		// L1 = L2 (or variable) < = These should be optimized away ideally
		// L1 = functioncall
		// L1 = functioncallL2L3..Lx
		// L1 = L2 [op] L3
		// L1 = (functioncallL1...Lx) [op] Ly
		// L1 = L2 [op] function
		// L1 = !L2

		//Identify pattern of code:
		String[] tokens = s.split("=");
		String[] expression = null;
		String op = "";
		String cmp = "";
		//tokens[0] is destination of expression
		// Resolve what is in tokens[1]
		if(tokens.length > 1){
			if(Pattern.matches("[0-9]*", tokens[1])) { // Constant asssigned to LHS
				ArrayList<String> dest = memory.accessReference(tokens[0], context);
				writeAccess(dest);
				output.add("movl $" + tokens[1] + ", " + dest.get(dest.size() - 1));
				return i;

			//Now check for arithmetic in tokens[1]. Stroe lhs and rhs in expression
			//Expression will be handled post if-else chain
			} else if(Pattern.matches("[a-zA-Z_0-9]*[+][a-zA-Z_0-9]*", tokens[1])){ //Addition
				expression = tokens[1].split("[+]");
				op = "addl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*-[a-zA-Z_0-9]*", tokens[1])){ //Subtraction
				expression = tokens[1].split("-");
				op = "subl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*[*][a-zA-Z_0-9]*", tokens[1])){ //Multiplication
				expression = tokens[1].split("[*]");
				op = "imull";
			} else if(Pattern.matches("[a-zA-Z_0-9]*/[a-zA-Z_0-9]*", tokens[1])){ //Division
				expression = tokens[1].split("/");
				op = "idivl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*>>[a-zA-Z_0-9]*", tokens[1])){ //Right Shift
				expression = tokens[1].split(">>");
				op = "shr";
			} else if(Pattern.matches("[a-zA-Z_0-9]*<<[a-zA-Z_0-9]*", tokens[1])){ //Left Shift
				expression = tokens[1].split("<<");
				op = "shl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*<[a-zA-Z_0-9]*", tokens[1])){ //Less Than
				expression = tokens[1].split("<");
				op = "cmp";
				cmp = "<";
			} else if(Pattern.matches("[a-zA-Z_0-9]*>[a-zA-Z_0-9]*", tokens[1])){ //Greater Than
				expression = tokens[1].split(">");
				op = "cmp";
				cmp = ">";
			} else if(Pattern.matches("[a-zA-Z_0-9]*<=[a-zA-Z_0-9]*", tokens[1])){ //Less Than or Equal
				expression = tokens[1].split("<=");
				op = "cmp";
				cmp = "<=";
			} else if(Pattern.matches("[a-zA-Z_0-9]*>=[a-zA-Z_0-9]*", tokens[1])){ //Greater Than or Equal
				expression = tokens[1].split(">=");
				op = "cmp";
				cmp = ">=";
			} else if(Pattern.matches("[a-zA-Z_0-9]*==[a-zA-Z_0-9]*", tokens[1])){ //Equal to
				expression = tokens[1].split("==");
				op = "cmp";
				cmp = "==";
			} else if(Pattern.matches("[a-zA-Z_0-9]*!=[a-zA-Z_0-9]*", tokens[1])){ //Not Equal to
				expression = tokens[1].split("!=");
				op = "cmp";
				cmp = "!=";
			} else if(Pattern.matches("[a-zA-Z_0-9]*[&][a-zA-Z_0-9]*", tokens[1])){ //And- binary
				expression = tokens[1].split("[&]");
				op = "andl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*\\^[a-zA-Z_0-9]*", tokens[1])){ //Xor- binary
				expression = tokens[1].split("^");
				op = "xorl";
			} else if(Pattern.matches("[a-zA-Z_0-9]*[|][a-zA-Z_0-9]*", tokens[1])){ //OR- binary
				expression = tokens[1].split("|");
				op = "orl";
			} else if(Pattern.matches("[a-zAzA-Z_0-9]*[&][&][a-zA-Z_0-9]*", tokens[1])){ //And- Logic
				expression = tokens[1].split("[&][&]");
				op = "andl";
			} else if(Pattern.matches("[a-zAzA-Z_0-9]*[|][|][a-zA-Z_0-9]*", tokens[1])){ //OR- Logic
				expression = tokens[1].split("[|][|]");
				op = "orl";
			} else if(Pattern.matches("[!][a-zA-Z][a-zA-Z_0-9]*", tokens[1])){ //Not
				expression = tokens[1].split("!");
				ArrayList<String> src = memory.accessReference(tokens[1], context);
				writeAccess(src);
				ArrayList<String> dest = memory.accessReference(tokens[0], context);
				writeAccess(dest);
				output.add("notl " + src.get(src.size() - 1)); //negate src
				output.add("movl " + src.get(src.size() - 1) + ", " + dest.get(dest.size() - 1)); //Store result
				return i;
			} else { //expression is a function call or variable
				for(String f: functions){
					if(f.length() <= tokens[1].length() /*&& f.equals(tokens[1].substring(0, f.length()))*/){
						System.out.println("tokens[1] "+ tokens[1].substring(0, f.length()));
						//Found a function call
						//Save currrent registers
						//get arguments
						//Call function
						System.out.println("Found function: " + tokens[1]);

						//Result should be in eax
						// assign to tokens[0]
			/****NO CURRENT SUPPORT FOR FUNCTION CALLS****/
						// ArrayList<String> dest = memory.accessReference(tokens[0], context);
						// output.add("movl %eax, " + dest.get(dest.size() - 1));
						return i;
					}
				}
				//If we don't return from for loop, there was no function call.
				//we must have a variable
				ArrayList<String> src = memory.accessReference(tokens[1], context);
				writeAccess(src);
				ArrayList<String> dest = memory.accessReference(tokens[0], context);
				writeAccess(dest);
				output.add("movl " + src.get(src.size() - 1) + ", " + dest.get(dest.size() - 1));
				return i;
			}
			//Need to load both sides of op
			boolean lhf = false;
			boolean rhf = false;
			ArrayList<String> lhs = null; //Expression[0]
			ArrayList<String> rhs = null; //Expression[1]
			/*Check for function calls on both sides*/
			for(String f: functions){
				/*LHS*/
				//Debug: System.out.println("f: " + f + " Expression[0] " + expression[0] + "Expression[1] " + expression[1]);
				if(f.length() <= expression[0].length() && f.equals(expression[0].substring(0, f.length()))){

					lhf = true;
					System.out.println("Found lhs function: " + expression[0] + " OP: " + op);

		/****NO CURRENT SUPPORT FOR FUNCTION CALLS****/
					// ArrayList<String> dest = memory.accessReference(tokens[0], context);
					// output.add("movl %eax, " + dest.get(dest.size() - 1));
				}
				/*RHS*/
				if(f.length() <= expression[1].length() && f.equals(expression[1].substring(0, f.length()))){

					System.out.println("Found rhs function: " + expression[1] + " OP: " + op);

		/****NO CURRENT SUPPORT FOR FUNCTION CALLS****/
					// ArrayList<String> dest = memory.accessReference(tokens[0], context);
					// output.add("movl %eax, " + dest.get(dest.size() - 1));
				}
			}
			boolean lhc = false;
			if(op.equals("idivl") && !lhf && !rhf){
				//Division has some special behavior
				lhs = memory.grabRegister(expression[0], context, "%eax");
				writeAccess(lhs);
				rhs = memory.accessReference(expression[1], context);
				writeAccess(rhs);
				output.add("idivl " + rhs.get(rhs.size() - 1));
				ArrayList<String> dest = memory.accessReference(tokens[0], context);
				writeAccess(dest);
				output.add("movl " + lhs.get(lhs.size() - 1) + ", " + dest.get(dest.size() - 1));
			}
			if(!lhf){ //lhs is not a function
				//check if variable or constant
				if(Pattern.matches("[0-9]*", expression[0])) { // Constant asssigned to LHS
					lhs = new ArrayList<String>();
					lhs.add("$" + expression[0]);
					lhc = true;
				} else {
					lhs = memory.accessReference(expression[0], context);
					writeAccess(lhs);
				}
			}
			if(!rhf){ //rhs is not a function
				if(Pattern.matches("[0-9]*", expression[1])) { // Constant asssigned to RHS
					/*Small optimization to save memory if rhs is a constant but lhs is not*/
					if(lhc){ /*If left hand side is a constant, allocate a destination register for rhs*/
						rhs = memory.accessReference(expression[1], context);
						writeAccess(rhs);
						output.add("movl $" + expression[1] + ", " + rhs.get(rhs.size() - 1));
					} else { /*Use lhs as destination register.*/
						rhs = lhs;
						lhs = new ArrayList<String>();
						lhs.add("$" + expression[1]);
					}
				} else {
					rhs = memory.accessReference(expression[1], context);
					writeAccess(rhs);
				}
			}
			//Enables complex logic via registers
			if(op.equals("cmp") && !lhf && !rhf){
				if(cmp.equals("==")){
					output.add("nandl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				} else if(cmp.equals("!=")){
					output.add("andl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				} else if(cmp.equals("<")){
					output.add("subl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					output.add("nandl $0x80000000, " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				} else if(cmp.equals(">")){
					output.add("subl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					//0x10000000 indicates negative
					output.add("and $0x80000000, " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				} else if(cmp.equals("<=")){
						//a <= b  ====  (a - 1) < b
					output.add("subl  $1, " + lhs.get(lhs.size() - 1));
					output.add("subl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					//0x10000000 indicates negative
					output.add("nandl $0x80000000, " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				} else if(cmp.equals(">=")){
						//a >= b  ====  (a + 1) > b
					output.add("addl  $1, " + lhs.get(lhs.size() - 1));
					output.add("subl " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
					//0x10000000 indicates negative
					output.add("andl $0x80000000, " + rhs.get(rhs.size() - 1));
					//Equal to 0 if true;
					ArrayList<String> dest = memory.accessReference(tokens[0], context);
					writeAccess(dest);
					output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
				}
				return i;
			}
			/*Temporary while functions are not supported*/
			if(!lhf && !rhf){
				output.add(op + " " + lhs.get(lhs.size() - 1) + ", " + rhs.get(rhs.size() - 1));
				ArrayList<String> dest = memory.accessReference(tokens[0], context);
				writeAccess(dest);
				output.add("movl " + rhs.get(rhs.size() - 1) + ", " + dest.get(dest.size() - 1));
			}

			// ArrayList<String> src = memory.accessReference(tokens[1], context);
			// writeAccess(src);
			// ArrayList<String> dest = memory.accessReference(tokens[0], context);
			// writeAccess(dest);
			// output.add(op + " " + src.get(src.size() - 1) + ", " + dest.get(dest.size() - 1));
			//break down tokens[1] further to implement
		}
		//Default return
		return i;
	}

	//Writes code from a memory access to output, writes nothing if access was in register prior to access call.
	public void writeAccess(ArrayList<String> access){
		for(int i = 0; i < access.size() - 1; i++){
			output.add(access.get(i));
		}
	}



}
