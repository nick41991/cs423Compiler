PARSER_BEGIN(Compiler)

import java.util.*;

public class Compiler{
	public static ArrayList<SyntaxToken> tokenList = new ArrayList<SyntaxToken>();

  	private static void printSuccess(){
  		System.out.println("Input Parsed Successfully!");
  	}

	private static void printTokens(){
		for(SyntaxToken tok : tokenList){
			System.out.println(tok.toString());
		}
	}

	private static void printParseTree(){
		System.out.println("Not Yet Implemented");
	}

    // Run the parser
	public static void main ( String args [ ] ) {
      		Compiler parser;
		boolean tokenBool = false;
		boolean parseTreeBool = false;
		boolean fileSet = false;
		String fileName = null;


		for(String s : args){
			if(s.equals("-t")){
				tokenBool = true;
			} else if (s.equals("-pt")){
				parseTreeBool = true;
			} else if (!fileSet){
				fileName = s;
				fileSet = true;
			} else {
				System.out.println("Error: More than one file passed as argument.");
				return;
			}
		}

		//Mostly for easy debugging, may not be in final version
		if(!fileSet){
        		System.out.println("C Parser:  Reading from standard input . . .");
        		parser = new Compiler(System.in);
      		}

      		else if(fileSet){
        		System.out.println("C Parser:  Reading from file " + fileName + " . . ." );
      			try {
        			parser = new Compiler(new java.io.FileInputStream(fileName));
      			}
      			catch(java.io.FileNotFoundException e){
        			System.out.println("C Parser:  File " + args[0] + " not found.");
        			return;
        		}
      		} else {
        		System.out.println("Compiler:  Usage is one of:");
        		System.out.println("         java Compiler [-t] [-pt] [fileName]");
        		return;
      		}
      		try {
        		parser.Program();
			if(tokenBool){
				printTokens();
			}
			if(parseTreeBool){
				printParseTree();
			}
        		System.out.println("Compiler:  C program parsed successfully.");
      		}
      		catch(ParseException e){
        		System.out.println("Compiler:  Encountered errors during parse.");
        		e.printStackTrace();
      		}
    	}
}

PARSER_END(Compiler)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}


TOKEN : { //Literals
 	<INTEGER_LITERAL: (["1"-"9"])* ["0"-"9"]> |
	<CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'"> |
	<STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

TOKEN : { //Keywords
	<CONTINUE: "continue"> |
	<RETURN: "return"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<IF: "if"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<GOTO: "goto"> |
	<INT: "int">  |
	<VOID: "void">
}

TOKEN : { //Identifiers
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

void Program() : {}
{
	(DeclarationList())+
	{printSuccess();}
}

void DeclarationList() : {}
{
	(Declaration())+
}

void Declaration() : {}
{
	( LOOKAHEAD( VarDeclaration() ) VarDeclaration() | FuncDeclaration() )
}

void VarDeclaration() : {}
{
	TypeSpecifier() <IDENTIFIER> ";"
}

void TypeSpecifier() : {}
{
	(<INT> | <VOID>)
}

void FuncDeclaration() : {}
{
	TypeSpecifier() <IDENTIFIER> "(" Params() ")" CompoundStatement()
}

void Params() : {}
{
	( LOOKAHEAD( ParamList() ) ParamList() | <VOID> )
}

void ParamList() : {}
{
	[(LOOKAHEAD( Param() )  Param() | Param() ("," Param())+)]
}

void Param() : {}
{
	TypeSpecifier() <IDENTIFIER>
}

void CompoundStatement() : {}
{
	"{" LocalDeclarations() StatementList() "}"
}

void LocalDeclarations() : {}
{
	(VarDeclaration())*
}

void StatementList() : {}
{
	(Statement())+
}

void Statement() : {}
{
	( LOOKAHEAD(2) LabeledStatement() | //Labels for goto
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() ) // goto and returns
}

void LabeledStatement() : {}
{
	( <IDENTIFIER> ":" Statement() )
}

void ExpressionStatement() : {}
{
 	[ Expression() ] ";"
}

void SelectionStatement() : {}
{
	( <IF> "(" Expression() ")" Statement() [ LOOKAHEAD(2) <ELSE> Statement() ] )
}

void IterationStatement() : {}
{
	( <WHILE> "(" Expression() ")" Statement() )
}

void JumpStatement() : {}
{
	( <GOTO> <IDENTIFIER> ";" |
	  <CONTINUE> ";" |
	  <BREAK> ";" |
	  <RETURN> [ Expression() ] ";" )
}

void Expression() : {}
{
	LOOKAHEAD(Variable() AssignmentOperator()) Variable() AssignmentOperator() Expression() | LOOKAHEAD(Negation()) Negation() | LogicalORExpression()
}

void Negation() : {}
{
	"!" Expression()
}

void Variable() : {}
{
	[LOOKAHEAD(TypeSpecifier()) TypeSpecifier()] <IDENTIFIER>
}

void AssignmentOperator() : {}
{
	( "=" | "*=" | "/=" | "+=" | "-=" )
}

//Boolean Operations have lower precedence than Mathematical Operations so they are higher in the parse tree

//Boolean Operations: Order of precedence (low to high): || -> && -> | -> ^ -> & -> == or != -> <, >, <=, or >=
void LogicalORExpression() : {Token lor;}
{
	LogicalANDExpression() [ lor = "||" LogicalORExpression() ]
	{
		tokenList.add(new SyntaxToken("LOGICOP", lor.image));
	}
}

void LogicalANDExpression() : {Token land;}
{
	InclusiveORExpression() [ land = "&&" LogicalANDExpression() ]
	{
		tokenList.add(new SyntaxToken("LOGICOP", land.image));
	}
}

void InclusiveORExpression() : {Token o;}
{
	ExclusiveORExpression() [ o = "|" InclusiveORExpression() ]
	{
		tokenList.add(new SyntaxToken("BINARYOP", o.image));
	}
}

void ExclusiveORExpression(Token e;) : {}
{
	ANDExpression() [ e = "^" ExclusiveORExpression() ]
	{
		tokenList.add(new SyntaxToken("BINARYOP", e.image));
	}
}

void ANDExpression() : {Token a;}
{
	EqualityExpression() [ a = "&" ANDExpression() ]
	{
		tokenList.add(new SyntaxToken("BINARYOP", a.image));
	}
}

void EqualityExpression() : {Token e; Token n;}
{
	RelationalExpression() [ ( e = "==" n = "!=" )
	{
		tokenList.add(new SyntaxToken("RELOP", e.image));
		tokenList.add(new SyntaxToken("RELOP", n.image));
	} EqualityExpression() ]
}

void RelationalExpression() : {Token l; Token g; Token le; Token ge;}
{
	ShiftExpression() [ ( l = "<" g = ">" le = "<=" ge = ">=" )
	{
		tokenList.add(new SyntaxToken("RELOP", l.image));
		tokenList.add(new SyntaxToken("RELOP", g.image));
		tokenList.add(new SyntaxToken("RELOP", le.image));
		tokenList.add(new SyntaxToken("RELOP", ge.image));
	}
	RelationalExpression() ]

}
//End of Booleans

//Mathematical Operations: Order of precedence (low to high): >> or << -> + or - -> *, /, or %
void ShiftExpression() : {}
{
	AdditiveExpression() [ ( "<<" | ">>" ) ShiftExpression() ]
}

void AdditiveExpression() : {Token p; Token m;}
{
	MultiplicativeExpression() [ ( p = "+" m = "-" )
	{
		tokenList.add(new SyntaxToken("ADDOP", p.image));
		tokenList.add(new SyntaxToken("ADDOP", m.image));
	}
	AdditiveExpression() ]

}

void MultiplicativeExpression() : {Token mult; Token div; Token mod;}
{
	Factor() [ ( mult = "*" div = "/" mod = "%" )
	{
		tokenList.add(new SyntaxToken("MULOP", mult.image));
		tokenList.add(new SyntaxToken("MULOP", div.image));
		tokenList.add(new SyntaxToken("MULOP", mod.image));
	}
	MultiplicativeExpression() ]

}

void Factor() : {}
{
	"(" LogicalORExpression() ")" |
	LOOKAHEAD(Call()) Call() |
	Variable() |
	Constant()
}

void Call() : {Token t; Token l; Token r;}
{
	(t = <IDENTIFIER> l = "(" Args() r = ")")
	{
		tokenList.add(new SyntaxToken("IDENTIFIER", t.image));
		tokenList.add(new SyntaxToken("LPAREN", l.image));
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
}

void Args() : {}
{
	(Expression())*
}

void Constant() : {Token i; Token l; Token s;}
{
	(i = <INTEGER_LITERAL> l = <CHARACTER_LITERAL> s = <STRING_LITERAL>)
	{
		tokenList.add(new SyntaxToken("INTEGER_LITERAL", i.image));
		tokenList.add(new SyntaxToken("CHARACTER_LITERAL", l.image));
		tokenList.add(new SyntaxToken("STRING_LITERAL", s.image));
	}
}
