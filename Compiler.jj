PARSER_BEGIN(Compiler)

import java.util.*;

public class Compiler{
	public static ArrayList<SyntaxToken> tokenList = new ArrayList<SyntaxToken>();

  	private static void printSuccess(){
  		System.out.println("Input Parsed Successfully!");
  	}

	private static void printTokens(){
		for(SyntaxToken tok : tokenList){
			System.out.println(tok.toString());
		}
	}

	private static void printParseTree(){
		System.out.println("Not Yet Implemented");
	}

    // Run the parser
	public static void main ( String args [ ] ) {
      		Compiler parser;
		boolean tokenBool = false;
		boolean parseTreeBool = false;
		boolean fileSet = false;
		String fileName = null;


		for(String s : args){
			if(s.equals("-t")){
				tokenBool = true;
			} else if (s.equals("-pt")){
				parseTreeBool = true;
			} else if (!fileSet){
				fileName = s;
				fileSet = true;
			} else {
				System.out.println("Error: More than one file passed as argument.");
				return;
			}
		}

		//Mostly for easy debugging, may not be in final version
		if(!fileSet){
        		System.out.println("C Parser:  Reading from standard input . . .");
        		parser = new Compiler(System.in);
      		}

      		else if(fileSet){
        		System.out.println("C Parser:  Reading from file " + fileName + " . . ." );
      			try {
        			parser = new Compiler(new java.io.FileInputStream(fileName));
      			}
      			catch(java.io.FileNotFoundException e){
        			System.out.println("C Parser:  File " + args[0] + " not found.");
        			return;
        		}
      		} else {
        		System.out.println("Compiler:  Usage is one of:");
        		System.out.println("         java Compiler [-t] [-pt] [fileName]");
        		return;
      		}
      		try {
        		parser.Program();
			if(tokenBool){
				printTokens();
			}
			if(parseTreeBool){
				printParseTree();
			}
        		System.out.println("Compiler:  C program parsed successfully.");
      		}
      		catch(ParseException e){
        		System.out.println("Compiler:  Encountered errors during parse.");
        		e.printStackTrace();
      		}
    	}
}

PARSER_END(Compiler)

SKIP : {
 " "
|  "\t"
|  "\n"
|  "\r"
|  <"//" (~["\n","\r"])* ("\n" | "\r" | "\r\n")>
|  <"/*" (~["*"])* "*" ("*" | ~["*","/"] (~["*"])* "*")* "/">
| "#" : PREPROCESSOR_OUTPUT
}

<PREPROCESSOR_OUTPUT> SKIP:
{
     "\n" : DEFAULT
}

<PREPROCESSOR_OUTPUT> MORE:
{
 "\\\n"
 |
 "\\\r\n"
 |
 < ~[] >
}


TOKEN : { //Literals
 	<INTEGER_LITERAL: (["1"-"9"])* ["0"-"9"]> |
	<CHARACTER_LITERAL: "\'" (~["\'","\\","\n","\r"] | "\\" (["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])? | ["0"-"3"] ["0"-"7"] ["0"-"7"])) "\'"> |
	<STRING_LITERAL: "\"" ( ~["\"","\\","\n","\r"] | "\\" ( ["n","t","b","r","f","\\","\'","\""] | ["0"-"7"] (["0"-"7"])?  | ["0"-"3"] ["0"-"7"] ["0"-"7"] | ( ["\n","\r"] | "\r\n")))* "\"">
}

TOKEN : { //Keywords
	<CONTINUE: "continue"> |
	<RETURN: "return"> |
	<WHILE: "while"> |
	<BREAK: "break"> |
	<IF: "if"> |
	<ELSE: "else"> |
	<CASE: "case"> |
	<GOTO: "goto"> |
	<INT: "int">  |
	<VOID: "void">
}

TOKEN : { //Identifiers
 <IDENTIFIER: <LETTER> (<LETTER> | <DIGIT>)*>
|  <#LETTER: ["$","A"-"Z","_","a"-"z"]>
|  <#DIGIT: ["0"-"9"]>
}

void Program() : {}
{
	(DeclarationList())+
	{printSuccess();}
}

void DeclarationList() : {}
{
	(Declaration())+
}

void Declaration() : {}
{
	( LOOKAHEAD( VarDeclaration() ) VarDeclaration() | FuncDeclaration() )
}

void VarDeclaration() : {Token i; Token s;}
{
	TypeSpecifier() i = <IDENTIFIER> s = ";"
	{
		tokenList.add(new SyntaxToken("IDENTIFIER", i.image));
		tokenList.add(new SyntaxToken("SEMICOLON", s.image));
	}
}

void TypeSpecifier() : {Token i; Token v;}
{
	(i = <INT>
	{tokenList.add(new SyntaxToken("TYPE_SPECIFIER", i.image));}
	| v = <VOID>
	{tokenList.add(new SyntaxToken("TYPE_SPECIFIER", v.image));}
	)
}

void FuncDeclaration() : {Token i; Token l; Token r;}
{
	TypeSpecifier() i = <IDENTIFIER> l = "("
	{
		tokenList.add(new SyntaxToken("IDENTIFIER", i.image));
		tokenList.add(new SyntaxToken("LPAREN", l.image));
	}
	Params() r = ")"
	{
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
	CompoundStatement()
}

void Params() : {Token v;}
{
	( LOOKAHEAD( ParamList() ) ParamList() | v = <VOID>
	{tokenList.add(new SyntaxToken("VOID", v.image));}
	)
}

void ParamList() : {Token c;}
{
	[(LOOKAHEAD( Param() )  Param() | Param() (c = ","
	{
		tokenList.add(new SyntaxToken("COMMA", c.image));
	}
	Param())+)]
}

void Param() : {Token i;}
{
	TypeSpecifier() i = <IDENTIFIER>
	{tokenList.add(new SyntaxToken("IDENTIFIER", i.image));}
}

void CompoundStatement() : {Token l; Token r;}
{
	(l = "{"
	{
		tokenList.add(new SyntaxToken("LBRACKET", l.image));
	}
	LocalDeclarations() StatementList()
	r = "}")
	{
		tokenList.add(new SyntaxToken("RBRACKET", r.image));
	}
}

void LocalDeclarations() : {}
{
	(VarDeclaration())*
}

void StatementList() : {}
{
	(Statement())+
}

void Statement() : {}
{
	( LOOKAHEAD(2) LabeledStatement() | //Labels for goto
	  ExpressionStatement() |
	  CompoundStatement() |
	  SelectionStatement() |
	  IterationStatement() |
	  JumpStatement() ) // goto and returns
}

void LabeledStatement() : {Token i; Token c;}
{
	( i = <IDENTIFIER> c = ":"
	{
		tokenList.add(new SyntaxToken("IDENTIFIER", i.image));
		tokenList.add(new SyntaxToken("COLON", c.image));
	}
	Statement() )
}

void ExpressionStatement() : {Token s;}
{
 	[ Expression() ] s = ";"
	{tokenList.add(new SyntaxToken("SEMICOLON", s.image));}
}

void SelectionStatement() : {Token i; Token l; Token r; Token e;}
{
	( i = <IF> l = "("
	{
		tokenList.add(new SyntaxToken("IF", i.image));
		tokenList.add(new SyntaxToken("LPAREN", l.image));
	}
	Expression() r = ")" Statement()
	{
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
	[ LOOKAHEAD(2) e = <ELSE> Statement()
	{tokenList.add(new SyntaxToken("ELSE", e.image));}
	] )
}

void IterationStatement() : {Token w; Token l; Token r;}
{
	( w = <WHILE> l = "("
	{
		tokenList.add(new SyntaxToken("WHILE", w.image));
		tokenList.add(new SyntaxToken("LPAREN", l.image));
	}
	Expression()
	r = ")" Statement() )
	{
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
}

void JumpStatement() : {Token t; Token id; Token s;}
{
	( t = <GOTO> id = <IDENTIFIER> s = ";"
	{
		tokenList.add(new SyntaxToken("GOTO", t.image));
		tokenList.add(new SyntaxToken("IDENTIFIER", id.image));
		tokenList.add(new SyntaxToken("SEMICOLON", s.image));
	}
	| t = <CONTINUE> s = ";"
	{
		tokenList.add(new SyntaxToken("CONTINUE", t.image));
		tokenList.add(new SyntaxToken("SEMICOLON", s.image));
	}
	| t = <BREAK> s = ";"
	{
		tokenList.add(new SyntaxToken("BREAK", t.image));
		tokenList.add(new SyntaxToken("SEMICOLON", s.image));
	}
	| t = <RETURN> [ Expression() ] s = ";"
	{
		tokenList.add(new SyntaxToken("RETURN", t.image));
		tokenList.add(new SyntaxToken("SEMICOLON", s.image));
	}
	)
}

void Expression() : {}
{
	LOOKAHEAD(Variable() AssignmentOperator()) Variable() AssignmentOperator() Expression() | LOOKAHEAD(Negation()) Negation() | LogicalORExpression()
}

void Negation() : {Token t;}
{
	(t = "!")
	{
		tokenList.add(new SyntaxToken("NEGATION", t.image));
	}
	Expression()
}

void Variable() : {Token i;}
{
	[LOOKAHEAD(TypeSpecifier()) TypeSpecifier()] i = <IDENTIFIER>
	{tokenList.add(new SyntaxToken("IDENTIFIER", i.image));}
}

void AssignmentOperator() : {Token t;}
{
	( t = "="
	{tokenList.add(new SyntaxToken("ASSIGNMENTOP", t.image));}
	| t = "*="
	{tokenList.add(new SyntaxToken("ASSIGNMENTOP", t.image));}
	| t = "/="
	{tokenList.add(new SyntaxToken("ASSIGNMENTOP", t.image));}
	| t = "+="
	{tokenList.add(new SyntaxToken("ASSIGNMENTOP", t.image));}
	| t = "-="
	{tokenList.add(new SyntaxToken("ASSIGNMENTOP", t.image));}
	)
}

//Boolean Operations have lower precedence than Mathematical Operations so they are higher in the parse tree

//Boolean Operations: Order of precedence (low to high): || -> && -> | -> ^ -> & -> == or != -> <, >, <=, or >=
void LogicalORExpression() : {Token t;}
{
	LogicalANDExpression() [ t = "||"
	{
		tokenList.add(new SyntaxToken("LOGICOP", t.image));
	}
	LogicalORExpression() ]

}

void LogicalANDExpression() : {Token t;}
{
	InclusiveORExpression() [ t = "&&"
	{
		tokenList.add(new SyntaxToken("LOGICOP", t.image));
	}
	LogicalANDExpression() ]

}

void InclusiveORExpression() : {Token t;}
{
	ExclusiveORExpression() [ t = "|"
	{
		tokenList.add(new SyntaxToken("BINARYOP", t.image));
	}
	InclusiveORExpression() ]

}

void ExclusiveORExpression() : {Token t;}
{
	ANDExpression() [ t = "^"
	{
		tokenList.add(new SyntaxToken("BINARYOP", t.image));
	}
	ExclusiveORExpression() ]

}

void ANDExpression() : {Token t;}
{
	EqualityExpression() [ t = "&"
	{
		tokenList.add(new SyntaxToken("BINARYOP", t.image));
	}
	ANDExpression() ]

}

void EqualityExpression() : {Token t;}
{
	RelationalExpression() [ ( t = "=="
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	| t = "!="
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	) EqualityExpression() ]
}

void RelationalExpression() : {Token t;}
{
	ShiftExpression() [ ( t = "<"
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	| t = ">"
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	| t = "<="
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	| t = ">="
	{tokenList.add(new SyntaxToken("RELOP", t.image));}
	) RelationalExpression() ]

}
//End of Booleans

//Mathematical Operations: Order of precedence (low to high): >> or << -> + or - -> *, /, or %
void ShiftExpression() : {Token l; Token r;}
{
	AdditiveExpression() [ ( l = "<<"
	{tokenList.add(new SyntaxToken("LSHIFT", l.image));}
	| r = ">>"
	{tokenList.add(new SyntaxToken("RSHIFT", r.image));}
	) ShiftExpression() ]
}

void AdditiveExpression() : {Token t;}
{
	MultiplicativeExpression() [ ( t = "+"
	{tokenList.add(new SyntaxToken("ADDOP", t.image));}
	| t = "-"
	{tokenList.add(new SyntaxToken("ADDOP", t.image));}
	)
	AdditiveExpression() ]
}

void MultiplicativeExpression() : {Token t;}
{
	Factor() [ ( t = "*"
	{tokenList.add(new SyntaxToken("MULOP", t.image));}
	| t = "/"
	{tokenList.add(new SyntaxToken("MULOP", t.image));}
	| t = "%"
	{tokenList.add(new SyntaxToken("MULOP",t.image));})
	MultiplicativeExpression() ]

}

void Factor() : {Token l; Token r;}
{
	l = "(" LogicalORExpression() r = ")"
	{
		tokenList.add(new SyntaxToken("LPAREN", l.image));
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
	| LOOKAHEAD(Call()) Call() | Variable() | Constant()
}

void Call() : {Token t; Token l; Token r;}
{
	(t = <IDENTIFIER> l = "(" Args() r = ")")
	{
		tokenList.add(new SyntaxToken("IDENTIFIER", t.image));
		tokenList.add(new SyntaxToken("LPAREN", l.image));
		tokenList.add(new SyntaxToken("RPAREN", r.image));
	}
}

void Args() : {}
{
	(Expression())*
}

void Constant() : {Token t;}
{
	(t = <INTEGER_LITERAL>
	{
		tokenList.add(new SyntaxToken("INTEGER_LITERAL", t.image));
	}
	| t = <CHARACTER_LITERAL>
	{
		tokenList.add(new SyntaxToken("CHARACTER_LITERAL", t.image));
	}
	| t = <STRING_LITERAL>
	{
		tokenList.add(new SyntaxToken("STRING_LITERAL", t.image));
	}
	)
}
